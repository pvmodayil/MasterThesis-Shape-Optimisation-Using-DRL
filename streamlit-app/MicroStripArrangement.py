#######################################
# Author : Philip Varghese Modayil
# Date   : 06.04.2024
# Topic  : Microstrip Arrangement 
#######################################

# importing libraries
import numpy as np
import mpmath as mp
from typing import *
import multiprocessing 

# class to hold the microstrip arrangement functions
class MicroStripArrangement:
    """
    This class initializes a micro strip arrangement and encapsulates the functions to calculate its properties
    """
    # constructor function 
    def __init__(self
        ,V0:float
        ,hw_arra:float
        ,ht_arra:float
        ,ht_subs:float
        ,hw_micrstr:float
        ,ht_micrstr:float
        ,er_1:float
        ,er_2:float
        ,num_fs:float) -> None:
        
        # Set up the microstrip
        self.V0 = V0 # potential of the microstrip
        self.hw_arra = hw_arra # half width of the arrangement
        self.ht_arra = ht_arra # height of the arrangement
        self.ht_subs = ht_subs # height of the substrate
        self.hw_micrstr = hw_micrstr # half width of the microstrip
        self.ht_micrstr = ht_micrstr # height of the microstrip
        self.er_1 = er_1 # relative permitivitty of medium 1(usually air)
        self.er_2 = er_2 # relative permitivitty of medium 2
        self.e0 = 8.85418781762e-12 # dielectric constant
        self.c = 299792458 # speed of light in vacuum (m/s)
        self.w_arra = 2*self.hw_arra # width of the arrangement
        self.w_micrstr = 2*self.hw_micrstr # width of the microstrip
        self.e1 = self.e0*self.er_1 # permitivitty of medium 1
        self.e2 = self.e0*self.er_2 # permitivitty of medium 2
        self.num_fs = num_fs # number of fourier coefficients(vn)
    
    # function to check monotonicity
    def monotonically_decreasing(self,g:np.ndarray) -> bool:
        """
        Function to check whether the suggested g values are monotonically decreasing
        Input
        -----------
        g: support points generated by the agent
            numpy array
    
        Output
        -----------
        boolean truth value 
        """
        # take the numpy differentiation
        dx = np.diff(g)
        
        # check if all first difference are negative
        # return the boolean value
        return np.all(dx < 0)
    
    def degree_of_monotonicity(self,g:np.ndarray) -> float:
        """
        Function to measure degree of monotonicity
        Input
        -----------
        g: support points generated by the agent
            numpy array
    
        Output
        -----------
        degree of monotonicity
        """   
        # take the numpy differentiation
        dx = np.diff(g)
        
        # count number of negative values
        return np.sum(dx<0)
    
    # convex or concave function
    def is_convex(self,g:np.ndarray) -> bool:
        """
        Function to check whether the suggested g values is a convex function
        Input
        -----------
        g: support points generated by the agent
            numpy array
    
        Output
        -----------
        boolean truth value 
        """
        # Check if the array has at least 3 elements
        if len(g) < 3:
            # print("The array should have at least 3 elements to perform convexity check.")
            return False
        
        # Calculate the second differences
        dx2 = g[2:] - 2 * g[1:-1] + g[:-2]
        
        # Check if all second differences are non-negative
        # return the boolean value
        return np.all(dx2 >= 0)
    
    # degree of convexity
    def degree_of_convex(self,g:np.ndarray) -> float:
        """
        Function to measure degree of convexity
        Input
        -----------
        g: support points generated by the agent
            numpy array
    
        Output
        -----------
        degree of convexity
        """
        
        # Calculate the second differences
        dx2 = g[2:] - 2 * g[1:-1] + g[:-2]
        
        # count number of positive values
        return np.sum(dx2>0)

    def potential_coeff(self,g:np.ndarray,x:np.ndarray) -> np.ndarray:
        """
        Function to calaculate the potential coefficients
        This function taken in g values for corresponding x valueswhich are from (hw_micrstr + delta to hw_arra - delta)
        
        Input
        -----------
        V0: potential of the microstrip
            float
        g: support points y-axis from agent
            numpy array
        x: support points x-axis
            numpy array
        hw_micrstr: halw width of the microstrip
                float
        hw_arra: half width of the arrangement
                float
        num_fs: number of fourier coefficients
                float
        
        Output
        -----------
        vn = potential coefficients  
            np.ndarray      
        """
        vn = []
        # repeat for num_fs times
        for n in range(self.num_fs):
            
            vn_n = ((g[0] - 1)/(x[0] - self.hw_micrstr))*(mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[0]) - mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*self.hw_micrstr))
            
            for i in range(1,len(x)):
                vn_n += ((g[i] - g[i-1])/(x[i] - x[i-1]))*(mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[i]) - mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[i-1]))
            
            vn_n += (g[-1]/(self.hw_arra - x[-1]))*mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[-1])
            vn_n *= 2/self.hw_arra*(self.V0/((2*n+1)*mp.pi/(2*self.hw_arra))**2)
            
            vn.append(float(vn_n))
        return np.array(vn)

    def calculate_vn_n(self,args:Tuple[float,np.ndarray,np.ndarray]) -> float:
        """
        Function to calaculate the potential coefficient
        This function taken in g values for corresponding x valueswhich are from (hw_micrstr + delta to hw_arra - delta)
        
        Input
        -----------
        n: fourier coefficient
            float
        V0: potential of the microstrip
            float
        g: support points y-axis from agent
            numpy array
        x: support points x-axis
            numpy array
        hw_micrstr: halw width of the microstrip
                float
        hw_arra: half width of the arrangement
                float
        
        Output
        -----------
        vn_n = potential coefficient
            float      
        """
        n, g, x = args
        vn_n = ((g[0] - 1)/(x[0] - self.hw_micrstr))*(mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[0]) - mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*self.hw_micrstr))
            
        for i in range(1,len(x)):
            vn_n += ((g[i] - g[i-1])/(x[i] - x[i-1]))*(mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[i]) - mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[i-1]))
        
        vn_n += (g[-1]/(self.hw_arra - x[-1]))*mp.cos((2*n+1)*(mp.pi/(2*self.hw_arra))*x[-1])
        vn_n *= 2/self.hw_arra*(self.V0/((2*n+1)*mp.pi/(2*self.hw_arra))**2)
        
        return float(vn_n)
    
    # function to calculate potential coefficient parallely
    def potential_coeff_parallel(self,g:np.ndarray,x:np.ndarray) -> np.ndarray:
        """
        Function to calaculate the potential coefficients parallelly
        This function taken in g values for corresponding x valueswhich are from (hw_micrstr + delta to hw_arra - delta)
        
        Input
        -----------
        V0: potential of the microstrip
            float
        g: support points y-axis from agent
            numpy array
        x: support points x-axis
            numpy array
        hw_micrstr: halw width of the microstrip
                float
        hw_arra: half width of the arrangement
                float
        num_fs: number of fourier coefficients
                float
        
        Output
        -----------
        vn = potential coefficients  
            np.ndarray      
        """
        pool = multiprocessing.Pool()

        args_list = [(n, g, x) for n in range(self.num_fs)]
        vn = pool.map(self.calculate_vn_n, args_list)
        pool.close()
        pool.join()
        
        return np.array(vn)
    
    # function to calculate the energy of the arrangement
    def energy(self,vn:np.ndarray) -> float:
        """
        Function to calaculate the total energy of the arrangement
        
        Input
        -----------
        e1: permitivitty of medium 1
            float
        e2: permitivitty of medium 2
            float
        v: array of potential coefficients
            numpy array
        hw_arra: halw width of the arrangement
                float
        ht_arra: height of the arrangement
                float
        ht_subs: height of the substrate
                float
        
        Output
        -----------
        w12 = total energy of the arrangement  
            float     
        """
        # follow the formula
        w1 = 0
        w2 = 0
        for n in range(len(vn)):
            w1 += (vn[n]**2)*(2*n+1)*mp.pi*mp.coth((2*n+1)*mp.pi*(self.ht_arra - self.ht_subs)/(2*self.hw_arra))
            w2 += (vn[n]**2)*(2*n+1)*mp.pi*mp.coth((2*n+1)*mp.pi*(self.ht_subs)/(2*self.hw_arra))
         
        w12 = float(self.e1*w1/4 + self.e2*w2/4)
        
        return w12
    
    def potential(self,vn:np.ndarray,x:np.ndarray) -> np.ndarray:
        """
        Function to calaculate the potential distribution
        
        Input
        -----------
        vn: fourier coefficients 
            numpy array
        x: x-axis coordinates
            numpy array
        
        Output
        -----------
        VF = potential distribution of the arrangement  
            numpy array      
        """
        
        for n in range(self.num_fs): # calculate sum of the fourier series for the potential
            if(n == 0): 
                VF =       vn[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # first element of sum
            else:
                VF = VF + vn[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # add every other element of the sum
                
        return VF
    
    def charge_density(self,vn:np.ndarray,x:np.ndarray) -> np.ndarray:
        """
        Function to calaculate the charge density
        
        Input
        -----------
        vn: fourier coefficients 
            numpy array
        x: x-axis coordinates
            numpy array
        
        Output
        -----------
        sigma_F = charge density of the arrangement  
            numpy array      
        """
        sigma_n = []
        for n in (range(self.num_fs)):
            # Calculate approximation of sigma coefficient
            sigma_nn = vn[n]*(2*n+1)*(mp.pi/(2*self.hw_arra))*(self.e2*mp.coth((2*n+1)*(mp.pi/(2*self.hw_arra))*self.ht_subs)+self.e1*mp.coth((2*n+1)*(mp.pi/(2*self.hw_arra))*(self.ht_arra-self.ht_subs)))
            sigma_n.append(float(sigma_nn))
            
        # calculate fourier approximation of charge density
        for n in (range(self.num_fs)):
            if(n == 0): 
                sigma_F = sigma_n[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # first element of sum
            else:
                sigma_F = sigma_F + sigma_n[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # add every other element of the sum 
        
        sigma_F = np.array([float(x) for x in sigma_F])
        
        return sigma_F
    
    def calculate_sigma_n(self,args:Tuple[float,float]) -> float:
        
        n,vn_n = args
        sigma_nn = vn_n*(2*n+1)*(mp.pi/(2*self.hw_arra))\
            *(self.e2*mp.coth((2*n+1)*(mp.pi/(2*self.hw_arra))*self.ht_subs)\
                + self.e1*mp.coth((2*n+1)*(mp.pi/(2*self.hw_arra))*(self.ht_arra-self.ht_subs)))    
        
        return float(sigma_nn)
    
    def charge_density_parallel(self,vn:np.ndarray,x:np.ndarray) -> np.ndarray:
        
        pool = multiprocessing.Pool()
        args_list = [(n, vn_n) for n,vn_n in enumerate(vn)]
        sigma_n = pool.map(self.calculate_sigma_n, args_list)
        pool.close()
        pool.join()
        sigma_n = np.array(sigma_n)
        
        # calculate fourier approximation of charge density
        for n in (range(self.num_fs)):
            if(n == 0): 
                sigma_F = sigma_n[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # first element of sum
            else:
                sigma_F = sigma_F + sigma_n[n] * np.cos((2*n+1)*(np.pi/(2*self.hw_arra))*x) # add every other element of the sum 
        
        sigma_F = np.array([float(x) for x in sigma_F])
        
        return sigma_F
    
    def capacitance(self,w:float) -> float:
        """
        Function to calaculate capacitance
        
        Input
        -----------
        w: energy
            float
        
        Output
        -----------
        C = capacitance  
            float      
        """
        
        C = (2*w)/(self.V0**2)
        
        return C
    